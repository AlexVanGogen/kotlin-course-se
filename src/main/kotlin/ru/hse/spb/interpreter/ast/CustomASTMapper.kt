package ru.hse.spb.interpreter.ast

import org.antlr.v4.runtime.tree.ErrorNode
import org.antlr.v4.runtime.tree.ParseTree
import org.antlr.v4.runtime.tree.RuleNode
import org.antlr.v4.runtime.tree.TerminalNode
import ru.hse.spb.antlr.LalalangParser
import ru.hse.spb.antlr.LalalangVisitor
import ru.hse.spb.antlr.LalalangLexer.*
import ru.hse.spb.interpreter.getLocation

/**
 * Default visitor generated by ANTLR is not good for us for the following reason:
 * If production of non-terminal A has alternatives (e.g. A -> bC | dE), then object for A
 * will have `c()` and `e()` as generated methods that return objects for
 * non-terminals C, E, respectively, and fields `b` and `d` for terminals.
 * So, we have redundant information, and we will have to handle all possible alternatives
 * every time when implementing new visitors.
 * Moreover, these methods can return null, and since generated code is Java code,
 * we will have problems with null-safety.
 *
 * This leads to implementation of custom elements hierarchy and custom abstract AST visitor
 * to minimize public interface for visitors implementation and guarantee null-safety.
 * This class is a mapper from ANTLR objects hierarchy to our custom one.
 */
class CustomASTMapper : LalalangVisitor<BasicLanguageElement> {

    override fun visitFile(ctx: LalalangParser.FileContext) = File(visitBlock(ctx.block()))

    override fun visitBlock(ctx: LalalangParser.BlockContext) = Block(ctx.statement().map { visitStatement(it) })

    override fun visitBlockWithBraces(ctx: LalalangParser.BlockWithBracesContext) = visitBlock(ctx.block())

    override fun visitStatement(ctx: LalalangParser.StatementContext): Statement =
            when {
                ctx.function() != null -> visitFunction(ctx.function())
                ctx.variable() != null -> visitVariable(ctx.variable())
                ctx.expression() != null -> visitExpression(ctx.expression())
                ctx.whileStatement() != null -> visitWhileStatement(ctx.whileStatement())
                ctx.ifStatement() != null -> visitIfStatement(ctx.ifStatement())
                ctx.assignment() != null -> visitAssignment(ctx.assignment())
                ctx.returnStatement() != null -> visitReturnStatement(ctx.returnStatement())
                else -> throw InvalidStatementException(ctx.start)
            }

    override fun visitFunction(ctx: LalalangParser.FunctionContext) = FunctionDeclaration(
            visitIdentifierExpression(ctx.Identifier()).identifier,
            if (ctx.parameterNames() != null) visitParameterNames(ctx.parameterNames()).identifiers else listOf(),
            visitBlockWithBraces(ctx.blockWithBraces()),
            ctx.start.line
    )

    override fun visitVariable(ctx: LalalangParser.VariableContext) = VariableDeclaration(
            visitIdentifierExpression(ctx.Identifier()).identifier,
            ctx.expression()?.let { visitExpression(ctx.expression()) },
            ctx.start.line
    )

    override fun visitParameterNames(ctx: LalalangParser.ParameterNamesContext) = ParameterNames(
            ctx.Identifier().map { visitIdentifierExpression(it).identifier }
    )

    override fun visitWhileStatement(ctx: LalalangParser.WhileStatementContext) = WhileStatement(
            visitExpression(ctx.expression()),
            visitBlockWithBraces(ctx.blockWithBraces()),
            ctx.start.line
    )

    override fun visitIfStatement(ctx: LalalangParser.IfStatementContext) = IfStatement(
            visitExpression(ctx.expression()),
            visitBlockWithBraces(ctx.ifTrueBody),
            ctx.ifFalseBody?.let { visitBlockWithBraces(ctx.ifFalseBody) },
            ctx.start.line
    )

    override fun visitAssignment(ctx: LalalangParser.AssignmentContext) = AssignmentStatement(
            visitIdentifierExpression(ctx.Identifier()).identifier,
            visitExpression(ctx.expression()),
            ctx.start.line
    )

    override fun visitReturnStatement(ctx: LalalangParser.ReturnStatementContext) = ReturnStatement(
            visitExpression(ctx.expression()),
            ctx.start.line
    )

    override fun visitExpression(ctx: LalalangParser.ExpressionContext): Expression =
            when {
                ctx.nested != null -> visitExpression(ctx.nested)
                ctx.functionCall() != null -> visitFunctionCall(ctx.functionCall())
                ctx.Identifier() != null -> visitIdentifierExpression(ctx.Identifier())
                ctx.Literal() != null -> visitLiteralExpression(ctx.Literal())
                ctx.unaryExpression() != null -> visitUnaryExpression(ctx.unaryExpression())
                else -> {
                    val left = visitExpression(ctx.left)
                    val right = visitExpression(ctx.right)
                    val operator = OperatorType.of(ctx.operator.text)
                    when (ctx.operator.type) {
                        MUL, DIV, MOD -> MultiplicativeExpression(left, operator, right)
                        PLUS, MINUS -> AdditiveExpression(left, operator, right)
                        LT, LEQ, GT, GEQ, EQ, NEQ -> ComparisonExpression(left, operator, right)
                        AND, OR -> LogicalExpression(left, operator, right)
                        else -> throw OperatorNotFoundException(ctx.operator)
                    }
                }
            }

    private fun visitIdentifierExpression(ctx: TerminalNode) = IdentifierExpression(visitTerminal(ctx) as Identifier)
    private fun visitLiteralExpression(ctx: TerminalNode) = LiteralExpression(visitTerminal(ctx) as Literal)


    override fun visitUnaryExpression(ctx: LalalangParser.UnaryExpressionContext) = UnarySignedExpression(
            visitExpression(ctx.expression()),
            if (ctx.MINUS() != null) Sign.MINUS else Sign.PLUS,
            ctx.start.line
    )

    override fun visitFunctionCall(ctx: LalalangParser.FunctionCallContext) = FunctionCallExpression(
            visitIdentifierExpression(ctx.Identifier()).identifier,
            if (ctx.arguments() != null) visitArguments(ctx.arguments()).values else listOf(),
            ctx.start.line
    )

    override fun visitArguments(ctx: LalalangParser.ArgumentsContext) = Arguments(
            ctx.expression().map { visitExpression(it) }
    )

    override fun visitTerminal(node: TerminalNode): BasicLanguageElement =
            when (node.symbol.type) {
                Identifier -> Identifier(node.toString(), node.symbol)
                Literal -> Literal(node.toString(), node.symbol)
                else -> throw InvalidTerminalException(node)
            }

    override fun visit(tree: ParseTree?) = null

    override fun visitChildren(node: RuleNode?) = null

    override fun visitErrorNode(node: ErrorNode?) = null
}